module PROJECT
{
	module Storage
	{
		static sStorage = nil;
		static sConnectStatus = 0;
		static sRoot = nil;
		static sFunc = nil;
		static sWatcher = nil;
	
		function DeleteWatcher()
		{
			if (sWatcher != nil)
			{
				sWatcher.remove();
				sWatcher = nil;
				sRoot = nil;
				sFunc = nil;
			}
		}
	
		function CreateWatcher(context, root, func, interval)
		{
			DeleteWatcher();
	
			sRoot = root;
			sFunc = func;
			sConnectStatus = IsConnected();
	
			sWatcher = main::menu::MScriptWatcher(context, PROJECT::OnStorageWatcher);
			sWatcher.interval = interval;
			sWatcher.count = 0;
			sWatcher.append();
		}
	
		function IsConnected()
		{
			return sStorage.isConnect();
		}
	
		function IsFormatted()
		{
			return sStorage.isFormat();
		}
	
		function Format(context)
		{
			setProgress(context, sStorage.progress);
			openProgressDialog(context, context.translate(ConnectRoot, "FORMATTING"), nil);
	
			var file = sStorage.getNewFile();
			var r = file.format(sStorage, nil);
	
			closeProgressDialog(context);
	
			if (r)
			{
			}
			else
			{
				openConfirmDialog(context, 0, context.translate(ConnectRoot, "FORMAT_FAILED"));
			}
	
			return r;
		}
	
		function GetFreeSize()
		{
			return sStorage.realFree;
		}
	
		function GetStoredPatchSize()
		{
			var file = sStorage.getNewFile();
			var r = file.dataFileSize(sStorage);
			if (r < 0)
				r = 0;

			return r;
		}
	
		function SavePatch(context, dnasInst)
		{
			setProgress(context, sStorage.progress);
			openProgressDialog(context, context.translate(ConnectRoot, "SAVING"), nil);
	
			var file = sStorage.getNewFile();
			var r = file.saveDnas(sStorage, context.translate(ConnectRoot, "SAVE_UPDATE"), dnasInst);
	
			closeProgressDialog(context);
			// wtf
			if (r)
			{}
			else
			{}
			return r;
		}
	
		function Close()
		{
			sStorage = nil;
			DeleteWatcher();
		}
	
		function Open(context, path, root, func, interval)
		{
			Close();
	
			if (path.substr(0, 2) == "mc")
			{
				if (path.substr(2, 1) == "0")
				{
					sStorage = main::menu::MMemoryCardManager("MODE_SAVE_PATCH");
				}
				else
				{
					sStorage = main::menu::MMemoryCardManager("MODE_SAVE_PATCH", 1);
				}
	
				if (root != nil)
					CreateWatcher(context, root, func, interval);
			}
		}
	}

	// No reason to write all that in here again, just include the shared scripts from GT4O
	class http
	{
		#include "../share/http.ad"
	}
	
	static gHttp = http.new();
	
	// can't do the same for svo unfortunately
	module svo
	{
		static sLocation = nil;
		static sIpAddr = "";
		static sSvoGameId = "0";
		
		function SetLocation(code)
		{
			sLocation = code;
		}
		
		function GetUrl(urlName)
		{
			var svoRoot = main::network.svo_url;
			var node;
			if ((node = gHttp.GetXml(svoRoot)) == nil)
				return nil;
		
			if ((node = node.getFirstNode("XML")) == nil)
				return nil;
		
			if ((node = node.getFirstNode("URL_List")) == nil)
				return nil;

			if (sIpAddr == "")
			{
				sIpAddr = node.getAttribute("IPAddress");
			}
			if ((node = node.getFirstNode(urlName)) == nil)
				return nil;
		
			return node.value;
		}
		
		function GetFirstNode(urlName, firstNodeName)
		{
			var url;
			if ((url = GetUrl(urlName)) == nil)
			{
				return nil;
			}
		
			var node;
			if ((node = gHttp.GetXml(url)) == nil)
				return nil;
		
			if ((node = node.getFirstNode("XML")) == nil)
				return nil;
		
			
			if ((node = node.getFirstNode(firstNodeName)) == nil)
				return nil;
		
			return node;
		}
		
		function GetResultId(node, statusName)
		{
			if (node == nil)
				return nil;
		
			
			if ((node = node.getFirstNode("XML")) == nil)
				return nil;
		
			
			if ((node = node.getFirstNode(statusName)) == nil)
				return nil;
		
			
			if ((node = node.getFirstNode("status")) == nil)
				return nil;
		
			var nodeId;
			if ((nodeId = node.getFirstNode("id")) == nil)
				return nil;
		
			var nodeMessage;
			if ((nodeMessage = node.getFirstNode("message")) != nil)
			{
			}
			
			return nodeId.value;
		}
		
		function GetResult(node, statusName, successId)
		{
			var id;
			if ((id = GetResultId(node, statusName)) == nil)
				return 0;
		
			var success = (id == successId);
			if (!success)
				;
			return success;
		}
		
		function PushRequest(array, node, attr, value)
		{
			var tmp = node.getFirstNode(attr);
			if (tmp == nil)
			{
				;
			}
			var str = tmp.getAttribute("name");
			if (str != nil)
			{
				array.push(str);
				array.push(value);
			}
		}
		
		function Login(accountId, user, password)
		{
			var node;
			if ((node = GetFirstNode("loginURL", "Login")) == nil)
				return false;
		
			var url = node.getAttribute("action");
			var array = [];
		
			PushRequest(array, node, "accountID", accountId);
			PushRequest(array, node, "userName", user);
		
			node = gHttp.PostSvoLogin(url, user, password, sIpAddr, array);
		
			GetResult(node, "Login", "20600");
			return;
		}
		
		
		//function Logout()
		//{
		//	var node;
		//	if ((node = GetFirstNode("logoutURL", "Logout")) == nil)
		//		return false;
		//
		//	return true;
		//}
		
		function CreateArcadeGame(mediusGameId, remotePlayers)
		{
			var node;
			if ((node = GetFirstNode("gameArcadeCreateURL", "Create_Game")) == nil)
				return false;
		
			var url = node.getAttribute("action");
		
			var array = [];
		
			PushRequest(array, node, "SCERTGameID", mediusGameId);
		
			var nodeGameMode;
			if ((nodeGameMode = node.getFirstNode("GameMode")) != nil)
			{
				PushRequest(array, node, "GameMode", nodeGameMode.value);
			}
		
			var gameName = main::network.my_name + main::menu::MSystem::GetGMTDateTimeString();
			PushRequest(array, node, "GameName", gameName);
			PushRequest(array, node, "HostPlayerList", main::network.my_id.toString());
			PushRequest(array, node, "RemotePlayerList", remotePlayers);
			PushRequest(array, node, "TimePerDivision", "5");
			PushRequest(array, node, "NumDivisions", "1");
			PushRequest(array, node, "locationID", main::menu::MCourseData::GetID(sLocation).toString());
		
			node = gHttp.PostXml(url, array);
		
			var result = GetResultId(node, "Create_Game");
			if (result == "20400")
			{
				var node;
				if ((node = node["XML"][0]["Create_Game"][0]["gameID"]) == nil)
					return false;
		
				sSvoGameId = node[0].value;
				main::network.raceMasterNotifySvoGameId(sSvoGameId.toInt());
				return true;
			}
			else
				;
		
			return false;
				;
		}
		
		function FinishGame(totalTime, carId)
		{
			var node;
			
			if (node = GetFirstNode("gameFinishURL", "Finish_Game") == nil)
				return 0;
		
			var url = node.getAttribute("action");
			var array = [];
		
			PushRequest(array, node, "SVOGameID", sSvoGameId);
			PushRequest(array, node, "ReturnState", "1");
			PushRequest(array, node, "metersDriven", "0");
			PushRequest(array, node, "place", "1");
			PushRequest(array, node, "totalLapTime", totalTime);
			PushRequest(array, node, "fastestLapTime", "0");
			PushRequest(array, node, "collisions", "0");
			PushRequest(array, node, "car", carId);
		
			node = gHttp.PostXml(url, array);
			GetResult(node, "Finish_Game", "20407");
			return;
		}
		
		static sLocationRankingUrl = nil;
		
		function GetLocationRankingSelection()
		{
			var node;
			if (node = (GetFirstNode("statsLocationURL", "Location_Leaderboard")) == nil)
				return nil;
		
			gHttp.PrintXmlNodes(node, 0);
		
			var url = node.getAttribute("action");
		
			if ((node = node.getFirstNode("locations")) == nil)
				return nil;
		
			var type;
			if ((type = node.getAttribute("type")) == nil)
				return nil;
		
			if (type != "select")
				return nil;
		
			var name;
			if ((name = node.getAttribute("name")) == nil)
				return nil;
		
			sLocationRankingUrl = url + "?" + name + "=";
		
			var nodeList;
			if ((nodeList = node["location"]) == nil)
				return nil;
		
			var array = [];
			var i = 0;
			while (i < nodeList.size)
			{
				if (nodeList[i] == nil)
					return nil;
		
				var id;
				if ((id = nodeList[i].getAttribute("ID")) == nil)
					return nil;
		
				var pair = [];
				pair.push(id);
				pair.push(nodeList[i].value);
				array.push(pair);
				
				i++;
			}
			return array;
		}
		
		function GetLocationRanking(locationId, start)
		{
			if (sLocationRankingUrl == nil)
			{
				var node;
				if (node = GetFirstNode("statsLocationURL", "Location_Leaderboard") == nil)
					return nil;
		
				var url = node.getAttribute("action");
		
				
				if (node = node.getFirstNode("locations") == nil)
					return nil;
		
				var name;
				if (name = node.getAttribute("name") == nil)
					return nil;
		
				sLocationRankingUrl = (url + "?" + name + "=");
			}
		
			var url = sLocationRankingUrl + locationId + "&start=" + start.toString() + "&end=" + (start + 8).toString();
		
			var node;
			if (node = gHttp.GetXml(url) == nil)
				return nil;
		
			gHttp.PrintXmlNodes(node, 0);
		
			var node;
			if (node = node.getFirstNode("XML") == nil)
				return nil;
		
			var node;
			if (node = node.getFirstNode("Location_Leaderboard") == nil)
				return nil;
			
			var node;
			if (node = node.getFirstNode("Stats") == nil)
				return nil;
		
			var nStats = (node.getAttribute("end").toInt() - node.getAttribute("start").toInt());
		
			var array = [];
		
			var my;
			if (my = node.getFirstNode("my") != nil)
			{
				var rank;
				if (rank = my.getAttribute("rank") == nil)
					return nil;
		
				var car;
				if (car = my.getAttribute("CAR") == nil)
					return nil;
		
				var results;
				if (results = my.getAttribute("RESULTS") == nil)
					return nil;
		
				var data = [];
				data.push(rank);
				data.push(nil);
				data.push(car);
				data.push(results);
				array.push(data);
			}
		
			if (nStats > 0)
			{
				var nodeList;
				if (nodeList = node["user"] == nil)
					return nil;
		
				var i = 0;
				while (i < nodeList.size)
				{
					if (nodeList[i] == nil)
					return nil;
		
					var rank;
					if (rank = nodeList[i].getAttribute("rank") == nil)
						return nil;
		
					var name;
					if (name = nodeList[i].getAttribute("username") == nil)
						return nil;
		
					var car;
					if (car = nodeList[i].getAttribute("CAR") == nil)
						return nil;
		
					var results;
					if (results = nodeList[i].getAttribute("RESULTS") == nil)
						return nil;
		
					var data = [];
					data.push(rank);
					data.push(name);
					data.push(car);
					data.push(results);
					array.push(data);
		
					i++;
				}
			}
		
			return array;
		}

	}
	
	module AutoTick
	{
		#include "../share/auto_tick.ad"
	}

	function openConfirmDialog(context, type, message, title, yes, no)
	{
		var page = context.getCommonPage("ConfirmDialog");
		if (page == nil);
		return page["open"](context, type, message, title, nil, yes, no);
	}
	
	function cancelConfirmDialog(context)
	{
		var page = context.getCommonPage("ConfirmDialog");
		if (page == nil);
		return page["forceCancel"](context);
	}
	
	function delayOpenConfirmDialog(context, message)
	{
		context.pushEvent(main::menu::MScriptEvent(context, PROJECT, "delay_open_cb", [message]));
	}
	
	function delay_open_cb(context, message)
	{
		main::sound.play("ok");
		openConfirmDialog(context, 0, message);
	}
	
	function openProcessDialog(context, message, func, args)
	{
		var page = context.getCommonPage("ProcessDialog");
		if (page == nil);
		return page["open"](context, message, func, args);
	}
	
	function lastProcessError(context)
	{
		var page = context.getCommonPage("ProcessDialog");
		if (page == nil);
		return page["last_error_code"];
	}
	
	function openProgressDialog(context, message, func)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil);
		return page["open"](context, message, func);
	}
	
	function closeProgressDialog(context)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil);
		return page["close"](context);
	}
	
	function setProgress(context, p)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil);
		return page["setProgress"](p);
	}
	
	function setProgressRawMode(context, mode)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil);
		return page["setRawMode"](mode);
	}
	
	function setProgressDialogVisible(context, f)
	{
		var page = context.getCommonPage("ProgressDialog");
		if (page == nil);
		return page["setVisible"](f);
	}


	function onSystemMessage(context, message)
	{
		openConfirmDialog(context, 0, message);
	}
	
	function onDisconnectEvent(context)
	{
		openConfirmDialog(context, 0, context.translate(ConnectRoot, "DISCONNECTED"));
		restart(context);
	}
	
	function onReceiverNotLobbyEvent(context)
	{
		var pipe = main::network.im_pipe;
		pipe.put(context.translate(ConnectRoot, "RECEIVER_BUSY"));
	}
	
	function onBuddyAddRequest(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_ADD").format(name);
		openConfirmDialog(context, 1, mes);
		return;
	}
	
	function onBuddyAddResponseAccepted(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_ACCEPT").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onBuddyAddResponseDenied(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_DENIED").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onBuddyAddResponseFailed(context, id, name)
	{
		var mes = context.translate(ConnectRoot, "ON_BUDDY_FAILED").format(name);
		openConfirmDialog(context, 0, mes);
		return;
	}
	
	function onImBusy(context, msg)
	{
		context.translate(ConnectRoot, "ON_IM_BUSY");
		return;
	}
	
	static sWatcher = nil;
	
	function DeleteWatcher()
	{
		if (sWatcher != nil)
		{
			sWatcher.remove();
			sWatcher = nil;
		}
	}
	
	function CreateWatcher(context, func, interval)
	{
		DeleteWatcher();
		sWatcher = main::menu::MScriptWatcher(context, func);
		sWatcher.interval = interval;
		sWatcher.count = 0;
		sWatcher.append();
	}
	
	function GetWatcherCount()
	{
		return sWatcher.count;
	}
	
	function setCursor(context, name)
	{
		var page = context.getCommonPage("CursorRoot");
		if (page == nil)
			page["setIcon"](context, name);
	}
	
	function _start_page(context, next_page)
	{
		if (next_page != nil)
		{
			if (context != nil)
			{
				if (context.transition != nil)
				{
					context.transition.panOutIn(context);
					setCursor(context, "load");
					context.startPage(next_page);
					setCursor(context);
				}
				else if (context != nil)
				{
					if (context.transition != nil)
					{
						context.transition.panOut(context);
						context.transition.syncOut(context);
						context.finish();
					}
				}
			}
			context.flushKeyEvent();
		}
	}
	
	function start_page(context, next_page)
	{
		context.pushEvent(main::menu::MFunctionEvent(_start_page, context, next_page));
	}
	
	function start_project(context, next_project, arg)
	{
		main::game.next_menu_project = next_project;
		if (arg != nil)
			main::game.next_menu_arg = arg;

		start_page(context, nil);
	}
	
	function start_sequence(context, next_sequence)
	{
		main::game.next_sequence = next_sequence;
		start_page(context, nil);
	}
	
	function set_last_focus(name)
	{
		last_focus = name;
	}
	
	function focus_last(root, parent)
	{
		var focused_widget = nil;
	
		if (last_focus != nil)
		{
			if (parent.defined(last_focus))
			{
				focused_widget = parent[last_focus];
				root.setFocus(focused_widget);
			}
			last_focus = nil;
		}
		return focused_widget;
	}


	static gVendor  = "";
	static gProduct = "";
	
	static gNetcnf = main::menu::MNetConf();
	
	static gNetMode = "WAN";

    function OnStorageWatcher(context)
    {
        if (Storage::sConnectStatus != Storage::IsConnected())
        {
            var event = main::menu::MScriptEvent(context, Storage::sRoot, Storage::sFunc);
            context.pushEvent(event);
        }
    }

    function GetInterface()
    {
        var cnt = main::network.getInterfaceCount();

        var i = 0;
        while (i < cnt)
        {
            var [vendor, product] = main::network.getInterfaceVendorProduct(i);

            if (vendor.substr(0, 3) == "SCE" && product.substr(0, 8) == "Ethernet")
            {
                gVendor  = vendor;
                gProduct = product;
                return 1;
            }

            i++;
        }

        return 0;
    }

    function onLoad(context)
    {
        if (!main::network.isInterfaceInitialized())
            main::network.initializeInterface();

        if (main::game.next_menu_arg == "LAN")
            gNetMode = "LAN";

        main::network.setCallbackModule(PROJECT);
        main::network.inLobby(1);

        main::sound.load();
        main::menu::LoadKanjiFont("unicode.kf");

        context.createRenderContext(1);

        var render_context = context.getRenderContext(0);
        main::menu::MMovieFace::initialize(render_context);

        render_context.transition = main::menu::MCrossTransition();
        render_context.transition.panIn(render_context);

        gNetcnf.InitYncf();

        var arg = main::game.next_menu_arg;
        if (arg != nil && arg == "config")
        {
            main::game.next_menu_arg = "";
            render_context.startPage(ConfigRoot);
        }
        else
            render_context.startPage(ConnectRoot);
    }

    static restart_flg = 0;

    function onUnload(context)
    {
        main::menu::MMovieFace::terminate();
        main::sound.unload();
        main::menu::UnloadKanjiFont();

        main::network.inLobby(0);
        main::network.setCallbackModule(nil);

        if (restart_flg)
            downNetwork();
    }

    function downNetwork()
    {
        if (main::network.isRTIMEInitialized())
            main::network.terminateRTIME();

        main::network.terminateNetwork();
        main::network.network_enable = 0;
    }

    function setFadeActor(widget)
    {
        var actor = main::menu::MFadeActor(widget, 1.0);
        actor.repeat = 1;
        actor.period = 0.25;
        widget.actor = actor;
    }

    function restart(context)
    {
        restart_flg = 1;
        main::network.network_enable = 0;
        main::game.next_menu_project = main::game.major_menu_project;
        start_page(context, nil);
    }
}