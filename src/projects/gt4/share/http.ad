static http = main::menu::MHttp();

method __init__()
{
	http.block = 0;
	http.timeout = 60 * 30;
	http.setProxyByNetConf(main::game.option.netconf);
}


method GetMHttp()
{
	return http;
}

method GetXml(url)
{
	http.getXml(url);
	return;
}

method PostXml(url, arg)
{
	http.postXml(url, arg);
	return;
}

method PostSvoLogin(url, user, password, ip, arg)
{
	if (!http.SVOLOGIN(url, user, password, ip, arg))
		return nil;

	if (!http.sync())
	{
		http.response();
		return nil;
	}

	var xml = main::menu::MXml();
	xml.parse(http.response());
	return xml.result;
}

method AsyncGet(url)
{
	if (!http.GET(url))
		return false;
	return true;
}

method Response()
{
	return http.response();
}

method IsDone()
{
	return http.isTransactionDone();
}

method HasError()
{
	if (http.isTransactionFailed())
		return true;
	return false;
}


method GetContentLength()
{
	return http.contentLength;
}

method GetEntitySize()
{
	return http.entitySize;
}

method Abort()
{
	http.abort();
	return;
}

method close()
{
	http.close();
}

method ppr(str, level)
{
	var p = "";
	var d = 0;

	while (d < level)
	{
		p += "  ";
		d++;
	}
}

method PrintXmlNodes(node, level)
{
	if (node.value != "")
	{
		ppr(node.value, level);
	}

	var attrs = node.attrs;
	var a = 0;
	while (a < attrs.size)
	{
		var p = "";
		var d = 0;
		while (d < level)
		{
			p += "  ";
			d++;
		}
		p += ":";

		var attrName = attrs[a];
		var attrValue = node.getAttribute(attrName);

		a++;
	}

	var names = node.elems;
	var i = 0;
	while (i < names.size)
	{
		var name = names[i];
		var nodeList = node[name];

		var j = 0;
		while (j < nodeList.size)
		{
			ppr("[" + name + "]", level);
			PrintXmlNodes(nodeList[j], level + 1);
			j++;
		}

		i++;
	}
}